let grid = document.querySelector('.gridBox');
let squares = document.querySelectorAll('.cells');
let settings = document.querySelector('.settings');
let allButtons = document.querySelectorAll('button');

const size = document.querySelector(".size");
const color = document.querySelector(".color");
const eraser = document.querySelector(".eraser");
const clear = document.querySelector('.clear');
const rainbow = document.querySelector('.rainbow');
const mosaic = document.querySelector('.mosaic');
const toggleGrid = document.querySelector('.toggleGrid');

let gridToggleFlag = 0;
let squareSize;
let gridSize = 16; // initial grid size

// gets new grid size and deletes current grid
function handleGridSize() {
    let new_size = parseInt(prompt('Enter size N for an NxN sized grid:'));
    // cancels the change request if grid size value was unchanged or not a number
    if (new_size === gridSize || isNaN(new_size)) {
        return;
    }
    gridSize = new_size;
    // removes all cells in the grid
    while (grid.firstChild) {
        grid.removeChild(grid.firstChild);
    }
    setGrid(gridSize); // calls function that generates new grid
};

// creates a new grid based on whatever grid size value was passed as a parameter
function setGrid(gridSize) {
    // create an NxN grid where N is the grid size value passed as a parameter
    for (let i = 0; i < (gridSize ** 2); i++) {
        let new_square = document.createElement("div");
        new_square.className = 'cells';
        grid.appendChild(new_square);
    };
    squareSize = 100 / gridSize;
    squares = document.querySelectorAll('.cells');
    // modify cell size as required to ensure all cells fit inside the fixed size grid container
    squares.forEach((square) => {
        square.style.width = `${squareSize}%`;
        square.style.height = `${squareSize}%`;
    });
    handleColor();
}

// default mode: sets color to black
function handleColor() {
    squares.forEach((square) => {
        square.addEventListener('mouseenter', () => {
            square.style.backgroundColor = `#231710`;
            square.style.opacity = 1;
        });
    });
};

// sets color to white to give the illusion of "erasing"
function handleEraser() {
    squares.forEach((square) => {
        square.addEventListener('mouseenter', () => {
            square.style.backgroundColor = '#bca193';
            square.style.opacity = 1;
        });
    });
};

// sets color of all cells in the grid to white to give the illusion of "clearing" the grid
function handleClear() {
    squares.forEach((square) => {
        square.style.backgroundColor = '#bca193';
        square.style.opacity = 1;
    });
    handleColor();
};

// every cell is given a random color to give a "rainbow" pattern
function handleRainbow() {
    // rgb values are generated by generating random numbers for the red, blue, and green values
    squares.forEach((square) => {
        var o = Math.round, r = Math.random, s = 255;
        let randomColor = 'rgba(' + o(r()*s) + ',' + o(r()*s) + ',' + o(r()*s) + ')';
        square.addEventListener('mouseenter', () => {
            // randomly generated color value is assigned as the cell background color
            square.style.backgroundColor = randomColor;
            square.style.opacity = 1;
        });
    });
}

// opacity of each new cell is increased incrementally as the cell is revisted
function handlemosaic() {
    squares.forEach((square) => {
        square.dataset.opacity = 0;
        square.addEventListener('mouseenter', () => {
            let currentOpacity = parseFloat(square.dataset.opacity);
            if (currentOpacity < 1) {
                currentOpacity += 0.1;
                square.dataset.opacity = currentOpacity;
            }
            square.style.opacity = currentOpacity;
        });
    });
}

// allows user to toggle the display of grid boxes
function handleGridDisplay() {
    // a toggle flag has been used to fix a bug where the toggle button had to be pressed two times
    // when trying to display the grid for the first time 
    if (gridToggleFlag === 0) {
        squares.forEach((square) => {
            square.style.border = '1px solid black';
        })
        gridToggleFlag = 1;
        return;
    }
    squares.forEach((square) => {
        if (square.style.border === 'none') {
            square.style.border = '1px solid black';
        } else {
            square.style.border = 'none';
        }
    });
}

// handles the css styling of each button in the settings panel
allButtons.forEach((button) => {
    button.style.width = `150px`;
    button.style.height = `50px`;
    button.style.fontWeight = `bold`;
    button.style.fontSize = `18px`;
    button.style.border = `4px solid #231710`;
    button.style.backgroundColor = `#b68121`;
})

// event listeners for all buttons in the settings panel
size.addEventListener('click', handleGridSize);
color.addEventListener('click', handleColor);
eraser.addEventListener('click', handleEraser);
clear.addEventListener('click', handleClear);
rainbow.addEventListener('click', handleRainbow);
mosaic.addEventListener('click', handlemosaic);
toggleGrid.addEventListener('click', handleGridDisplay);

// creates a grid with a predefined number of cells
setGrid(gridSize);